# 前端路由中 Hash 模式和 History 模式的区别。

### 核心概念

在单页应用（SPA）中，路由的切换本质上是**视图组件的切换**，而不是向服务器请求一个新的 HTML 页面。Hash 模式和 History 模式是实现这个目标的两种主要技术手段。

---

### 一、Hash 模式

#### 1. 工作原理
Hash 模式利用 URL 中 **锚点（#）** 后面的部分（称为 hash）来实现路由。

*   **关键点**：**hash 值的改变不会触发浏览器向服务器发送请求**。
*   **监听事件**：通过监听 `window` 的 `hashchange` 事件来感知路由变化。
*   **URL 示例**：`http://example.com/#/home`，`http://example.com/#/about`

#### 2. 实现机制
1.  当用户点击一个链接，例如 `<a href="#/about">关于</a>`，URL 会从 `http://example.com/#/home` 变成 `http://example.com/#/about`。
2.  由于 hash 变化不会导致页面刷新，但会触发 `hashchange` 事件。
3.  前端路由系统（如 Vue Router, React Router）监听这个事件，获取新的 hash 值（`#/about`）。
4.  路由系统根据这个 hash 值，匹配预先定义好的路由规则，从而渲染对应的组件（例如 About 组件）。

#### 3. 特点
*   **兼容性极佳**：所有主流浏览器都支持，可兼容到 IE8。
*   **部署简单**：因为 hash 部分不会被发送到服务器，所以服务器只需要一个根路径（如 `index.html`）的配置即可，无需任何特殊处理。无论用户直接访问 `http://example.com/#/home` 还是 `http://example.com/#/about`，服务器实际收到的请求都是 `http://example.com/`。
*   **URL 不美观**：URL 中带有一个 `#`，看起来不像一个真实的 URL，对 SEO 不友好（但现代搜索引擎如 Google 已经可以爬取 hash 模式的内容）。

---

### 二、History 模式

#### 1. 工作原理
History 模式利用了 HTML5 History Interface 中新增的 **`pushState()`** 和 **`replaceState()`** 方法。

*   **关键点**：这两个方法允许浏览器**修改历史记录栈**，并且**不会使页面刷新**。
*   **监听事件**：通过监听 `window` 的 `popstate` 事件来感知由用户操作（如点击浏览器前进/后退按钮）引起的历史记录变化。
*   **URL 示例**：`http://example.com/home`，`http://example.com/about`（看起来和普通 URL 毫无区别）。

#### 2. 实现机制
1.  当用户点击一个由路由库管理的链接时（例如 `<router-link to="/about">`），路由库内部会阻止链接的默认跳转行为，并调用 `history.pushState()` 方法，将 URL 优雅地修改为 `http://example.com/about`。
2.  同时，路由库会根据 `pushState` 的目标路径，手动渲染对应的组件（例如 About 组件）。
3.  当用户点击浏览器的前进或后退按钮时，URL 会发生变化，并触发 `popstate` 事件。路由库监听这个事件，然后根据新的 URL 路径渲染对应的组件。

#### 3. 特点
*   **URL 美观**：去掉了 `#`，看起来更像一个标准的 URL，对用户体验和 SEO 更友好。
*   **需要服务器端支持**：这是 History 模式最大的“坑”。因为像 `/home` 或 `/about` 这样的路径是前端路由虚构的，服务器上并没有对应的物理文件或路由。
    *   **问题场景**：用户直接访问 `http://example.com/about` 或在页面中刷新时，浏览器会向服务器发送一个对 `/about` 的真实 HTTP 请求。如果服务器没有正确的配置，会返回 404 错误。
*   **兼容性稍弱**：依赖 HTML5 History API，兼容性不如 Hash 模式（但 IE10 及以上都支持，对于现代浏览器开发已不是问题）。

---

### 三、核心区别对比表

| 特性 | Hash 模式 | History 模式 |
| :--- | :--- | :--- |
| **URL 美观度** | 不美观，带 `#` | 美观，与普通 URL 无异 |
| **兼容性** | 极好，兼容 IE8+ | 良好，兼容 IE10+（依赖 HTML5 History API） |
| **服务器配置** | **非常简单**，只需一个根路径的 Fallback | **必须配置**，将所有前端路由都重定向到 `index.html`，否则直接访问或刷新会 404 |
| **SEO 友好性** | 较差（但搜索引擎已优化） | 更好，语义化更强 |
| **实现原理** | 监听 `window.onhashchange` 事件 | 使用 `history.pushState` 和监听 `window.onpopstate` 事件 |

---

### 四、如何选择？实战考量

#### 选择 Hash 模式的情况：
1.  **不需要考虑 SEO 的内部系统（如后台管理系统）**：部署简单是最大优势。
2.  **对兼容性有极高要求（如需要支持 IE9及以下）**。
3.  **项目结构简单，不想折腾服务器配置**。

#### 选择 History 模式的情况：
1.  **面向公众的、需要良好 SEO 的网站**：干净的 URL 对搜索引擎更友好。
2.  **追求极致用户体验，希望 URL 看起来更正式**。
3.  **项目使用现代框架，且有能力配置服务器**。

---

### 五、History 模式的服务器配置示例

这是使用 History 模式的关键一步。你需要让服务器在收到不存在的资源请求时，不是返回 404，而是返回你的 SPA 入口页面（通常是 `index.html`），然后由前端路由自己去解析 URL 并渲染对应组件。

*   **Nginx**:
    ```nginx
    location / {
      try_files $uri $uri/ /index.html;
    }
    ```

*   **Node.js (Express)**:
    ```javascript
    app.get('*', (req, res) => {
      res.sendFile(path.resolve(__dirname, 'dist', 'index.html'));
    });
    ```

*   **Apache** (在项目根目录创建 `.htaccess` 文件):
    ```apache
    RewriteEngine On
    RewriteBase /
    RewriteRule ^index\.html$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.html [L]
    ```

### 总结

Hash 模式和 History 模式是现代 SPA 路由的两大基石。**Hash 模式胜在简单、省心**，适合要求快速上线、兼容性高或不需SEO的场景。**History 模式胜在优雅、专业**，能提供更好的用户体验和 SEO 基础，但需要额外的服务器配置作为支撑。

理解它们的底层原理和优缺点，能帮助你在不同项目中做出最合适的技术选型。