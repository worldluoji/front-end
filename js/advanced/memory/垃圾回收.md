# 垃圾回收

## 栈垃圾回收
当函数执行结束，JS引擎通过向下移动ESP指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。

## 堆垃圾回收
### 一、弱代假说
1、大部分对象存活时间很短
2、不被销毁的对象，会活的更久

### 二、分类
V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老年代中存放的生存时间久的对象。

### 三、新生代
算法：Scavenge 算法

原理：
- 1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
- 2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
- 3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中
- 4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。

对象晋升策略：经过两次垃圾回收依然还存活的对象，会被移动到老年代区域中。

### 四、老年代
#### 算法：标记 - 清除（Mark-Sweep）算法

原理：
- 1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
- 2、清除：将垃圾数据进行清除。

碎片：
对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

#### 算法：标记 - 整理（Mark-Compact）算法

原理：
- 1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。
- 2、整理：让所有存活的对象都向内存的一端移动
- 3、清除：清理掉端边界以外的内存

#### 优化算法：增量标记（Incremental Marking）算法

原理：
- 1、为了降低老生代的垃圾回收而造成的卡顿
- 2、V8把一个完整的垃圾回收任务拆分为很多小的任务
- 3、让垃圾回收标记和 JavaScript 应用逻辑交替进行

---

## 循环引用
在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。所以，从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。

```js
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```
在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。

### 限制：那些无法从根对象查询到的对象都将被清除
尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。