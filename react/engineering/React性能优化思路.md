# React性能优化思路
## 1. 不要过早的做性能优化
著名计算机科学家高德纳（Donald E. Knuth）在他的著作《计算机程序设计艺术》（TAOCP）中提出过：
“过早优化是万恶之源（Premature Optimization is the Root of All Evil）。”
强调了开发者在程序开发的早期阶段，有许多重要的工作要做，而优化程序这件事往往会占用了开发者过多的精力，却没能带来对等的收益。

## 2. 应用性能问题的表现
### 慢
比如首页加载慢，局部读取数据慢。

有研究表明这类等待时间保持在 1～2 秒以内时，用户满意度比较高。
当然，将这些时间尽量缩短，有助于进一步提升用户体验，如各大互联网搜索引擎的首页，首次加载时间普遍都优化到了短短的几百毫秒。

反过来说，如果用户在使用 Web 应用的过程中，明确抱怨了“慢”，说明这个“慢”已经超过了 2 秒这一阈值了。

### 卡
卡，比如鼠标、键盘交互的视觉反馈不及时，滚动时不连贯。

“卡”有标准吗？有个说法是人类注意不到 100ms 以内的延迟，这也就意味着包括视频游戏在内的 GUI 如果达到了 60FPS，
即每帧画面 16ms，那就已经是非常流畅了。所以可以说判断前端应用是否“卡”的衡量基准，是建立在 10～100ms 这个数量级上的。

“慢”和“卡”基本可以涵盖大部分前端性能问题了。但其实除了时间之外，还有资源这个维度。
计算资源、网络带宽资源、存储资源都与用户，尤其是浏览器用户直接相关。


## 定位性能问题
### 用性能优化的一个闭环逻辑
    ┌──────────────────────────────────────────────────────────┐
    │                                                          │
    │      先开发应用   ──────────────────────►   继续开发        │
    │                                                          │
    └─────────────┬─────────────────────────────▲──────────────┘
                  │                             │
           ┌──────▼─────┐  ┌────────────┐ ┌─────┴──────┐
           │ 出现性能问题 ├──► 定位性能问题 ├─► 解决性能问题 │
           │            │  │   的根源    │ │            │
           └────────────┘  └────────────┘ └────────────┘

### 慢的解决思路
首次页面加载慢和页面跳转慢的问题，可以通过浏览器的开发者工具来定位问题根源，是建立连接慢、等待服务器响应慢、下载慢，还是下载队列被阻塞了。
尤其推荐 Chrome 浏览器开发者工具中的 Lighthouse 工具。

页面局部读取数据慢和提交表单处理慢，这两种问题的根源更有可能是服务器处理慢。而短时间内多次页面刷新，则更多是用户体验设计的问题。

## 卡的解决思路
表单控件交互卡顿，和鼠标、键盘交互的视觉反馈不及时这两种表现，常见的根源是网页 JS 进行了比较耗时的同步操作，阻塞了网页的渲染。
页面纵向滚动不连贯常见于 DOM 内容过多的情况。页面长时间不响应，则有可能是因为进入了 JS 死循环。

React 浏览器扩展 React Developer Tools 里，包含一个 Profiler 性能分析功能，也可以用来定位性能问题。
建议在设置中勾选“记录每个组件渲染的原因”，可以帮助你巩固对组件渲染过程的理解。

比如 console.log ，它在部分环境中是同步执行的，如果大量使用会阻塞正常的业务代码，所以生产上一定要将console.log删除。

一个组件由于 state 变更而重新渲染，它的子组件和后代组件都会被重新渲染（哪怕 props 没变化）。
但它的父组件和祖先组件不会重新渲染，它的平级组件以及平级组件的子组件树也不会重新渲染，这是从设计上保证的。
如果这个规律被打破了，则需要检查代码是否不小心修改了其他组件的 state 或 context。

当然我们可以对上面的重新渲染逻辑进一步优化。优化方案之前我们已经学习过，你能记起来吗？是的，就是纯组件， React.memo 或 React.PureComponent API
```
const EnhancedMyChildComponent = React.memo(MyChildComponent);
```
很大一部分纯组件失效的情况，都是因为父组件给作为子组件的纯组件传递了函数类型的 props，
而这个函数在父组件的每次重新渲染中都会被重新创建，破坏了不可变性。解决方案则是利用hooks，只渲染一次。
```
const handleToggleAdmin = useCallback((evt) => {
  setIsAdmin(currentState => !currentState);
}, []);
```
除了纯组件，还有更高级的优化方案，比如针对长列表的部分渲染框架 react-window 或者 react-virtualized。