# Hooks
在 React 中，Hooks 就是把某个目标结果钩到某个可能会变化的数据源或者事件源上，
那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。

Hooks 提供了让你监听某个数据变化的能力。这个变化可能会触发组件的刷新，也可能是去创建一个副作用，又或者是刷新一个缓存。
那么定义要监听哪些数据变化的机制，其实就是指定 Hooks 的依赖项。

Hooks 中被钩的对象，不仅可以是某个独立的数据源，也可以是另一个 Hook 执行的结果，这就带来了 Hooks 的最大好处：逻辑的复用。

Hooks 在一定程度上更好地体现了 React 的开发思想，即从 State => View 的函数式映射。
此外， Hooks 也解决了 Class 组件存在的一些代码冗余、难以逻辑复用的问题。

Hooks 和  Class 两种方式在 React 开发中几乎是完全等价的，没有绝对的优劣。
如果你决定开始使用 Hooks，那么对于已有的 Class 组件，其实是完全没必要进行立刻重构的。只要在新的功能上，再来使用函数组件和 Hooks 就可以了。

React 提供的 Hooks 其实非常少，一共只有 10 个，比如 useState、useEffect、useCallback、useMemo、useRef、useContesxt 等等。

<br>

## Hooks使用规则
1. 所有 Hook 必须要被执行到，必须按顺序执行。
   
错误示例：
```
function MyComp() {
  const [count, setCount] = useState(0);
  if (count > 10) {
    // 错误：不能将 Hook 用在条件判断里
    useEffect(() => {
      // ...
    }, [count])
  }
  
  // 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了
  if (count === 0) {
    return 'No content';
  }

  // 错误：不能将 Hook 放在可能的 return 之后
  const [loading, setLoading] = useState(false);
  
  //...
  return <div>{count}</div>
}
```

2. Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，一种是在函数组件内，另外一种则是在自定义的 Hooks 里面。

总结了一下：
- Hooks 不能出现在条件语句或者循环中，也不能出现在 return 之后；
- Hooks 只能在函数组件或者自定义 Hooks 中使用。

## useState: 让函数组件具有维持状态的能力
```
// 定义一个年龄的 state，初始值是 42
const [age, setAge] = useState(42);
// 定义一个水果的 state，初始值是 banana
const [fruit, setFruit] = useState('banana');
// 定一个一个数组 state，初始值是包含一个 todo 的数组
const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
```
通常来说，我们要遵循的一个原则就是：state 中永远不要保存可以通过计算得到值。比如：
- 从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。
- 从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 state 里。
- 从 cookie、localStorage 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 state 里。

<br>

## useEffect：执行副作用
什么是副作用呢？通常来说，副作用是指一段和当前执行结果无关的代码。
比如说要修改函数外部的某个变量，要发起一个请求，等等。
也就是说，在函数组件的当次执行过程中，useEffect 中代码的执行是不影响渲染出来的 UI 的。
```
useEffect(callback, dependencies)
```
第一个为要执行的函数 callback，第二个是可选的依赖项数组 dependencies。
其中依赖项是可选的，如果不指定，那么 callback 就会在<strong>每次组件render()完后都执行</strong>；
如果指定了，那么只有<strong>依赖项中的值发生变化</strong>的时候，它才会执行。


总结一下，useEffect 让我们能够在下面四种时机去执行一个回调函数产生副作用：
- 每次 render 后执行：不提供第二个依赖项参数。比如 useEffect(() => {})。
- 仅第一次 render 后执行：提供一个空数组作为依赖项。比如 useEffect(() => {}, [])。
- 第一次以及依赖项发生变化后执行：提供依赖项数组。比如 useEffect(() => {}, [deps])。
- 组件 unmount 后执行：返回一个回调函数。比如 useEffect() => { return () => {} }, [])。

那么在定义依赖项时，我们需要注意以下三点：
- 依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。
- 依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。
- React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方。

```
function Sample() {
  // 这里在每次组件执行时创建了一个新数组
  const todos = [{ text: 'Learn hooks.'}];
  useEffect(() => {
    console.log('Todos changed.');
  }, [todos]);
}
```
代码的原意可能是在 todos 变化的时候去产生一些副作用，但是这里的 todos 变量是在函数内创建的，实际上每次都产生了一个新数组。
所以在作为依赖项的时候进行引用的比较，实际上被认为是发生了变化的。


## Eslint hooks 配置
```
npm install eslint-plugin-react-hooks --save-dev
yarn add eslint-plugin-react-hooks --save-dev
```
然后eslint配置文件中加入：
```
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    // 检查 Hooks 的使用规则
    "react-hooks/rules-of-hooks": "error", 
    // 检查依赖项的声明
    "react-hooks/exhaustive-deps": "warn"
  }
}
```