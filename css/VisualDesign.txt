1. text-align
text-align: justify; causes all lines of text except the last line to meet the left and right edges of the line box.
text-align: center; centers the text
text-align: right; right-aligns the text
And text-align: left; (the default) left-aligns the text.

2. u tag
<u>Ph.D. students</u>
With the u tag, the browser applies the CSS of text-decoration: underline; to the element.
Note: Try to avoid using the u tag when it could be confused for a link. 
Anchor tags also have a default underlined formatting.

3. strong 和 em
strong会加粗
em更多是强调：This displays text as italicized, as the browser applies the CSS of font-style: italic; to the element

4. s tag
With the s tag, the browser applies the CSS of text-decoration: line-through; to the element.

5. hr tag 
add a horizontal line across the width of its containing element.

6. rgba
you can add a background-color to the element holding the text you want to emphasize. 
rgba stands for:
  r = red
  g = green
  b = blue
  a = alpha/level of opacity
The RGB values can range from 0 to 255. The alpha value can range from 1, 
which is fully opaque or a solid color, to 0, which is fully transparent or clear. 
rgba() is great to use in this case, as it allows you to adjust the opacity. 
This means you don't have to completely block out the background.

7. box-shadow 
The box-shadow property applies one or more shadows to an element.
The box-shadow property takes values for

offset-x (how far to push the shadow horizontally from the element),
offset-y (how far to push the shadow vertically from the element),
blur-radius,
spread-radius and
color, in that order.
The blur-radius and spread-radius values are optional.

Multiple box-shadows can be created by using commas to separate properties of each box-shadow element:
box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);


8. opacity 
this property in CSS is used to adjust the opacity, or conversely, the transparency for an item.
A value of 1 is opaque, which isn't transparent at all.
A value of 0.5 is half see-through.
A value of 0 is completely transparent.

9. text-transform
The text-transform property in CSS is used to change the appearance of text. 
It's a convenient way to make sure text on a webpage appears consistently, without having to change the text content of the actual HTML elements.
The following table shows how the different text-transformvalues change the example text "Transform me".

Value	Result
lowercase	"transform me"
uppercase	"TRANSFORM ME"
capitalize	"Transform Me"
initial	Use the default value
inherit	Use the text-transform value from the parent element
none	Default: Use the original text

10. font-size and font-weight
字体大小和粗细

11. line-height 
this property to change the height of each line in a block of text.

12. :hover
a:hover {
    color: blue;
}
鼠标放上去显示蓝色

13. relative
When the position of an element is set to relative, it allows you to specify how CSS should move it relative 
to its current position in the normal flow of the page. It pairs with the CSS offset properties of left or right, 
and top or bottom. These say how many pixels, percentages, or ems to move the item away from where 
it is normally positioned. The following example moves the paragraph 10 pixels away from the bottom:
p {
    position: relative;
    bottom: 10px;
}
相对于它本来应该在的位置，

14. absolute
absolute, which locks the element in place relative to its parent container.
Unlike the relative position, this removes the element from the normal flow of the document, 
so surrounding items ignore it.

15. fixed
fixed position, which is a type of absolute positioning that locks an element relative to the browser window.

16. z-index
When elements are positioned to overlap (i.e. using position: absolute | relative | fixed | sticky), 
the element coming later in the HTML markup will, by default, appear on the top of the other elements. 
However, the z-index property can specify the order of how elements are stacked on top of one another. 
It must be an integer (i.e. a whole number and not a decimal), 
and higher values for the z-index property of an element move it higher in the stack than those with lower values.

17. color theory
1) tertiary color (第三色)
Computer monitors and device screens create different colors by combining amounts of red, green, and blue light. 
This is known as the RGB additive color model in modern color theory. 
Red (R), green (G), and blue (B) are called primary colors. 
Mixing two primary colors creates the secondary colors cyan (G + B), magenta (R + B) and yellow (R + G). 
You saw these colors in the Complementary Colors challenge. 
These secondary colors happen to be the complement to the primary color not used in their creation, 
and are opposite to that primary color on the color wheel. For example, magenta is made with red and blue, 
and is the complement to green.

Tertiary colors are the result of combining a primary color with one of its secondary color neighbors. 
For example, within the RGB color model, red (primary) and yellow (secondary) make orange (tertiary). 
This adds six more colors to a simple color wheel for a total of twelve.

There are various methods of selecting different colors that result in a harmonious combination in design. 
One example that can use tertiary colors is called the split-complementary color scheme. 
This scheme starts with a base color, then pairs it with the two colors that are adjacent to its complement. 
The three colors provide strong visual contrast in a design, but are more subtle than using two complementary colors.
即用一个base color, 找相邻颜色(有两个相邻的)的secondary color, 最终得到tertiary color。 最终，base color + 两个tertiary color 三种颜色组合。

2) opposite colors
The Complementary Colors challenge showed that opposite colors on the color wheel can make each other 
appear more vibrant when placed side-by-side. However, the strong visual contrast can be jarring 
if it's overused on a website, and can sometimes make text harder to read if it's placed on a complementary-colored background. 
In practice, one of the colors is usually dominant and the complement is used to bring visual attention to certain content on the page.
常常用来引起视觉注意，让用户关注某块内容。

3) hsl
Colors have several characteristics including hue, saturation, and lightness. CSS3 introduced the hsl() property 
as an alternative way to pick a color by directly stating these characteristics.

色相、饱和度、亮度：
Hue is what people generally think of as 'color'. If you picture a spectrum of colors starting with red on the left, 
moving through green in the middle, and blue on right, the hue is where a color fits along this line. 
In hsl(), hue uses a color wheel concept instead of the spectrum, where the angle of the color on the circle is given 
as a value between 0 and 360.

Saturation is the amount of gray in a color. A fully saturated color has no gray in it, 
and a minimally saturated color is almost completely gray. This is given as a percentage with 100% being fully saturated.

Lightness is the amount of white or black in a color. A percentage is given ranging from 0% (black) to 100% (white), 
where 50% is the normal color.

olor	HSL
red 	hsl(0, 100%, 50%)
yellow	hsl(60, 100%, 50%)
green	hsl(120, 100%, 50%)
cyan	hsl(180, 100%, 50%)
blue	hsl(240, 100%, 50%)
magenta	hsl(300, 100%, 50%)

Mixing white with a pure hue creates a tint（色调） of that color, and adding black will make a shade（阴影）. 
Alternatively, a tone is produced by adding gray or by both tinting and shading. 
Recall that the 's' and 'l' of hsl() stand for saturation and lightness, respectively. 
The saturation percent changes the amount of gray and the lightness percent determines how much white or black is 
in the color. This is useful when you have a base hue you like, but need different variations of it.

18. CSS Linear Gradient
基本使用方法：
background: linear-gradient(gradient_direction, color 1, color 2, color 3, ...);

90deg makes a horizontal gradient (from left to right) and 45deg makes a diagonal gradient (from bottom left to top right).

Example:
background: linear-gradient(90deg, red, yellow, rgb(204, 204, 255));
Use a linear-gradient() for the div element's background, 
and set it from a direction of 35 degrees to change the color from #CCFFFF to #FFCCCC.

19. repeating-linear-gradient
similar to linear-gradient() with the major difference that it repeats the specified gradient pattern
example:
div{
    border-radius: 20px;
    width: 70%;
    height: 400px;
    margin:  50 auto;
    background: repeating-linear-gradient(
      45deg,
      yellow 0px,
      yellow 40px,
      black 40px,
      black 80px
    );
}

45度，0-40px黄色，40px到80px黑色，不断循环。


20. background
url('https://cdn-media-1.freecodecamp.org/imgr/MJAkxbh.png') 设置背景图


21. transform
1) To change the scale of an element, CSS has the transform property, along with its scale() function
example:
#ball2 {
    left: 65%;
    transform: scale(1.5);
}
ball2方法到1.5倍

p:hover {
    transform: scale(2.1);
}

2) skewX(), which skews(斜，扭曲) the selected element along its X (horizontal) axis by a given degree.
例如：transform: skewX(24deg);
同样的还有transform: skewY(-10deg);

21. box-shadow + border-radis画一个蓝月亮
<style>
  .center {
    position: absolute;
    margin: auto;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    width: 100px;
    height: 100px;
    background-color: transparent;
    border-radius: 50%;
    box-shadow: 25px 10px 0 0 blue;
  }

</style>
<div class="center"></div>


22. heart
the ::before and ::after pseudo-elements. 
These pseudo-elements are used to add something before or after a selected element.

For the ::before and ::after pseudo-elements to function properly, they must have a defined content property. 
This property is usually used to add things like a photo or text to the selected element. 
When the ::before and ::after pseudo-elements are used to make shapes, the content property is still required, 
but it's set to an empty string.

利用伪元素，使用css画一个爱心：

<style>
  .heart {
    position: absolute;
    margin: auto;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: pink;
    height: 50px;
    width: 50px;
    transform: rotate(-45deg);
  }
  .heart::after {
    background-color: pink;
    content: "";
    border-radius: 50%;
    position: absolute;
    width: 50px;
    height: 50px;
    top: 0px;
    left: 25px;
  }
  .heart::before {
    content: "";
    background-color: pink;
    border-radius: 50%;
    position: absolute;
    width: 50px;
    height: 50px;
    top: -25px;
    left: 0px;
  }
</style>
<div class="heart"></div>
heart其实一个矩形，进行了45度旋转。然后前后各弄了一个圆，通过移位变成两个半圆，最终组成了爱心。

23. @keyframes
To animate an element, you need to know about the animation properties and the @keyframes rule. 
The animation properties control how the animation should behave and the @keyframes rule controls 
what happens during that animation. There are eight animation properties in total.

1) animation-name : sets the name of the animation, which is later used by @keyframes to tell CSS 
which rules go with which animations.

2) animation-duration : sets the length of time for the animation.

3) animation-fill-mode : specifies the style applied to an element when the animation has finished.

4) opacity: you'll change the opacity of an animated element so it gradually fades 
as it reaches the right side of the screen.

5) animation-iteration-count: which allows you to control how many times you would like to loop through the animation.

6) animation-timing-function: controls how quickly an animated element changes over the duration of the animation.
There are a number of predefined keywords available for popular options. 
For example, the default value is ease, which starts slow, speeds up in the middle, and then slows down again in the end. 
Other options include ease-out, which is quick in the beginning then slows down, ease-in, which is slow in the beginning, 
then speeds up at the end, or linear, which applies a constant animation speed throughout.

@keyframes is how to specify exactly what happens within the animation over the duration. 
This is done by giving CSS properties for specific "frames" during the animation, with percentages ranging from 0% to 100%.
If you compare this to a movie, the CSS properties for 0% is how the element displays in the opening scene. 
The CSS properties for 100% is how the element appears at the end, right before the credits roll. 
Then CSS applies the magic to transition the element over the given duration to act out the scene.

example 1：矩形颜色随进度变化，位置上下移动
<style>
div {
  height: 40px;
  width: 70%;
  background: black;
  margin: 50px auto;
  border-radius: 5px;
}

#rect {
  animation-name: rainbow;
  animation-duration: 4s;
}

@keyframes rainbow {
  0% {
    background-color: blue;
    top: 0px;
  }

  50% {
    background-color: green;
    top: 25px;
  }

  100% {
    background-color: yellow;
    top: -25px;
  }
}

</style>
<div id="rect"></div>

example 2: use CSS @keyframes to change the color of a button in its hover state.

<style>
  button {
    border-radius: 5px;
    color: white;
    background-color: #0F5897;
    padding: 5px 10px 8px 10px;
  }

  button:hover {
    animation-name: background-color;
    animation-duration: 500ms;
    animation-fill-mode: forwards;
    animation-iteration-count: infinite; // 表示无限循环
  }

  @keyframes background-color {
    100% {
      background-color: #4791d0;
    }
  }

</style>
<button>Register</button>

example 3: opacity 球从左到右逐渐消失
<style>

  #ball {
    width: 70px;
    height: 70px;
    margin: 50px auto;
    position: fixed;
    left: 20%;
    border-radius: 50%;
    background: linear-gradient(
      35deg,
      #ccffff,
      #ffcccc
    );
    animation-name: fade;
    animation-duration: 3s;
  }

  @keyframes fade {
    50% {
      left: 60%;
      opacity: 0.1;
    }
  }

</style>
<div id="ball"></div>

7) cubic-bezier
In CSS animations, Bezier curves are used with the cubic-bezier function. 
The shape of the curve represents how the animation plays out. 
The curve lives on a 1 by 1 coordinate system. 
The X-axis of this coordinate system is the duration of the animation (think of it as a time scale), 
and the Y-axis is the change in the animation.

The cubic-bezier function consists of four main points that sit on this 1 by 1 grid: p0, p1, p2, and p3. 
p0 and p3 are set for you - they are the beginning and end points which are always located respectively
at the origin (0, 0) and (1, 1). You set the x and y values for the other two points, 
and where you place them in the grid dictates the shape of the curve for the animation to follow. 
This is done in CSS by declaring the x and y values of the p1 and p2 "anchor" points in the form: (x1, y1, x2, y2). 
Pulling it all together, here's an example of a Bezier curve in CSS code:

animation-timing-function: cubic-bezier(0.25, 0.25, 0.75, 0.75);

In the example above, the x and y values are equivalent for each point (x1 = 0.25 = y1 and x2 = 0.75 = y2), 
which if you remember from geometry class, results in a line that extends from the origin to point (1, 1). 
This animation is a linear change of an element during the length of an animation, 
and is the same as using the linear keyword. In other words, it changes at a constant speed.
