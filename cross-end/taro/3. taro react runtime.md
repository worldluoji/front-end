# taro react runtime
React框架可以简单分为三部分：react-core + react-reconciler + Renderer
- react-core提供了供开发者调用的核心API，以jsx为DSL描述语言；
- react-reconciler 内部基于“双缓存”的调和机制维护了Fiber组件树，并完整实现了Diff算法，决定何时更新、更新什么；
- Renderer 则具体实现客户端的渲染，以及DOM事件处理；

react-dom是浏览器端的Renderer，调用DOM、BOM API来渲染界面。但在小程序环境中，则行不通。好在react-reconciler提供了HostConfig接口，理论上只要按照HostConfig接口实现对应方法，就可以在任意端完成界面渲染。

Taro提供了 @tarojs/taro-react 包，用来连接 react-reconciler 和 taro-runtime 的 BOM/DOM API。它就是基于 react-reconciler 的小程序专用 React 渲染器，连接 @tarojs/runtime 的 DOM 实例，相当于小程序版的react-dom，暴露的 API 也和 react-dom 保持一致。

<div style="display: flex; align-items: center; justify-content: center">
    <img src="./images/taro react.png" />
</div>

## 1、实现宿主配置
完整实现HostConfig接口，在方法中调用对应的Taro BOM/DOM API:
```ts
// taro-react/src/reconciler.ts
import { document } from '@tarojs/runtime' // 模拟了window、document全局对象
const hostConfig = {
    createInstance (type) {
        return document.createElement(type)
    },
    // ...
}
const TaroReconciler = Reconciler(hostConfig)
export { TaroReconciler }
```
## 2、实现渲染函数

核心逻辑是暴露 render 方法：
```ts
// taro-react/src/render.ts
import { TaroReconciler } from './reconciler'
class Root {
    constructor(renderer, domContainer){
	this.renderer = renderer
        // 值得注意的是，传入ConcurrentMode，则会启用了React18中并发新特性
	this.internalRoot = renderer.createContainer(domContainer, 0/** LegacyRoot: react-reconciler/src/ReactRootTags.js */, false, null)
    }
    render(children, cb){
	const { renderer, internalRoot } = this
	renderer.updateContainer(children, internalRoot, null, cb)
	return renderer.getPublicRootInstance(internalRoot)
    }
    unmount (cb: Callback) {
        this.renderer.updateContainer(null, this.internalRoot, null, cb)
    }
}
export function render(element, domContainer, cb){
    const root = new Root(TaroReconciler, domContainer)
    ContainerMap.set(domContainer, root)
    return root.render(element, cb)
}
```

## 3、封装为小程序版‘react-dom’
```ts
import {render} from './render'
export default {
  render,
  // 其他方法  
}
```

### render何时调用？
如果前端框架为React时，在编译时，会引入插件 taro-plugin-react, 插件内会调用 modifyMiniWebpackChain —> setAlias
```ts
if(framework === 'react'){
    // 别名，在小程序内调用ReactDOM就是刚才封装的小程序版react-dom
    alias.set('react-dom$', '@tarojs/react')
}
```

用户编写的app.js会被 createReactApp 方法包裹，在createReactApp方法中会调用 ReactDOM.render 方法
```ts
// taro-plugin-react/src/runtime/connect.ts
if (process.env.TARO_ENV !== 'h5') {
    appWrapper = ReactDOM.render?.(h(AppWrapper), document.getElementById('app'))
}
```

<img src="./images/taro react-mini.png" />

### 视图
小程序逻辑层描述业务逻辑，而视图层则负责展示内容，两者通过基于Data/Event的jsbridge进行通信。在小程序环境需要提前将视图描述出来，不可以在逻辑层去动态生成视图(所以React.createPortal用不了)。
不过小程序提供了template的模板能力，支持在视图层通过mustache语法来动态渲染视图。

Taro使⽤了模板拼接的⽅式，根据运⾏时提供的 DOM 树数据结构，各 templates 递归地 相互引⽤，最终可以渲染出对应的动态 DOM 树。

#### 模板化处理
首先，将小程序的所有组件挨个进行模版化处理，从而得到小程序组件对应的模版。如下图就是小程序的 view 组件模版经过模版化处理后的样子。⾸先需要在 template ⾥⾯写⼀个 view，把它所有的属性全部列出来（把所有的属性都列出来是因为⼩程序⾥⾯不能去动态地添加属性）。以下是view的模板化呈现：
```ts
<template name="tmpl_0_view">
    <view
        hover-class="{{xs.b(i.hoverClass,'none')}}"
        hover-stop-propagation="{{xs.b(i.hoverStopPropagation,false)}}"
        hover-start-time="{{xs.b(i.hoverStartTime,50)}}"
        hover-stay-time="{{xs.b(i.hoverStayTime,400)}}"
        bindtouchstart="eh"
        bindtouchmove="eh"
        bindtouchend="eh"
        bindtouchcancel="eh"
        bindlongpress="eh"
        animation="{{i.animation}}"
        bindanimationstart="eh"
        bindanimationiteration="eh"
        bindanimationend="eh"
        bindtransitionend="eh"
        style="{{i.st}}"
        class="{{i.cl}}"
        bindtap="eh"
        id="{{i.uid||i.sid}}"
        data-sid="{{i.sid}}"
    >
        <block wx:for="{{i.cn}}" wx:key="sid">
            <template is="{{xs.e(cid+1)}}" data="{{i:item,l:l}}" />
        </block>
    </view>
</template>
<template name="tmpl_1_view">...</template>
```
组件模板化的核心代码在 packages/shared/src/template.ts 文件中。

可以在打包出dist目录中的base.wxml中看到所有组件模板化的结果，当然Taro只会将项目中使用到的组件进行输出。

同时，Taro会建立一个根模板，每个页面都会从 taro_tmpl 开始递归渲染：
```ts
<wxs module="xs" src="./utils.wxs" />
<template name="taro_tmpl">
  <block wx:for="{{root.cn}}" wx:key="sid">
    <template is="tmpl_0_container" data="{{i:item,l:''}}" />
  </block>
</template>
<template name="tmpl_0_container">
  <template is="{{xs.a(0, i.nn, l)}}" data="{{i:i,cid:0,l:xs.f(l,i.nn)}}" />
</template>

<!-- 页面内调用 -->
<import src="../../base.wxml"/>
<template is="taro_tmpl" data="{{root:root}}" />
```
可以通过端平台插件的template来控制不同端平台模板的输出; 模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 `<wxs />` 模块。

当业务触发this.setState时，进一步触发小程序的this.setData，从而更新data，触发模板更新。

<br>

## data
有了组件模板，就需要data来注入灵魂了(Taro中叫注水hydrate，这里并非ssr的hydrate)，在运行时中会组建完整的data数据。

首先，在createPageConfig中会对config.data进行初始化，赋值`{root:{cn:[]}}`，同时Taro会对onLoad生命周期进行特殊处理:
```ts
// packages/taro-runtime/src/dsl/common.ts
function createPageConfig(){
    // config会作为小程序 Page() 的入参
    const config = {
	// 在Taro中会对onLoad绑定this，详见具体源码
	onLoad(this){
            // 页面加载后触发onLoad生命周期，执行以下逻辑
            const pageElement = document.getElementById($taroPath) // pageElement是TaroRootElement的实例对象
            pageElement.ctx = this  // 这里的this指向的是小程序当前页面实例，在下文的performUpdate方法中会使用到
            pageElement.performUpdate(true, cb) // 这里开始正式触发页面渲染,
	}
    } 
    config.data = {root:{cn:[]}}
    return config
}
```
React在commit阶段会调用HostConfig里的appendInitialChild方法完成页面挂载，在Taro中则继续调用：appendInitialChild —> appendChild —> insertBefore —> enqueueUpdate
```ts
// packages/taro-runtime/src/dom/root.ts
class TaroRootElement extends TaroElement {
    updatePayloads = []
    enqueueUpdate (payload) {
        this.updatePayloads.push(payload)
    }
    performUpdate(){
	const ctx = this.ctx
	setTimeout(()=>{
            const data = Object.create(null)
            const resetPaths = new Set(['root.cn.[0]', 'root.cn[0]'])
            while (this.updatePayloads.length > 0) {
                const { path, value } = this.updatePayloads.shift()
                if (path.endsWith('cn')) {
                    resetPaths.add(path)
                }
                data[path] = value
            }
            for (const path in data) {
                resetPaths.forEach(p => {
                if (path.includes(p) && path !== p) {
                    delete data[path]
                }
            })
            const value = data[path]
            if (isFunction(value)) {
              data[path] = value()  // hydrate, 执行注水逻辑，会产生完整的data数据
            }
        }
            ctx.setData(normalUpdate, cb)  // 调用小程序this.setData，触发页面视图初始化
        }, 0)
    }
}
```
注意这一行代码 `data[path] = value()` ，value就是调用的hydrate方法，hydrate会将data”注满水“：
```ts
// packages/taro-runtime/src/hydrate.ts
function hydrate (node) {
    const data = {
        'nn': nodeName,
        'sid': node.sid
    }
    if (node.uid !== node.sid) {
        data.uid = node.uid
     }
    let { childNodes } = node
    data['cn'] = childNodes.map(hydrate) // 递归为子节点data注水
    data['cl'] = node.className
    return data
}
```
你可以在小程序IDE中的 “AppData” 标签栏中查看到完整的data数据结构。当在React中调用 this.setState 时，React内部会执行reconciler，进而触发 enqueueUpdate 方法。

<br>

## reference
- https://juejin.cn/post/7087041847700226062?from=search-suggest
- https://juejin.cn/post/6989968343163731981
- https://github.com/SyMind/how-taro3-work/blob/main/part-one.md