# taro react runtime
React框架可以简单分为三部分：react-core + react-reconciler + Renderer
- react-core提供了供开发者调用的核心API，以jsx为DSL描述语言；
- react-reconciler 内部基于“双缓存”的调和机制维护了Fiber组件树，并完整实现了Diff算法，决定何时更新、更新什么；
- Renderer 则具体实现客户端的渲染，以及DOM事件处理；

react-dom是浏览器端的Renderer，调用DOM、BOM API来渲染界面。但在小程序环境中，则行不通。好在react-reconciler提供了HostConfig接口，理论上只要按照HostConfig接口实现对应方法，就可以在任意端完成界面渲染。

Taro提供了 @tarojs/taro-react 包，用来连接 react-reconciler 和 taro-runtime 的 BOM/DOM API。它就是基于 react-reconciler 的小程序专用 React 渲染器，连接 @tarojs/runtime 的 DOM 实例，相当于小程序版的react-dom，暴露的 API 也和 react-dom 保持一致。

<div style="display: flex; align-items: center; justify-content: center">
    <img src="./images/taro react.png" />
</div>

## 1、实现宿主配置
完整实现HostConfig接口，在方法中调用对应的Taro BOM/DOM API:
```ts
// taro-react/src/reconciler.ts
import { document } from '@tarojs/runtime' // 模拟了window、document全局对象
const hostConfig = {
    createInstance (type) {
        return document.createElement(type)
    },
    // ...
}
const TaroReconciler = Reconciler(hostConfig)
export { TaroReconciler }
```
## 2、实现渲染函数

核心逻辑是暴露 render 方法：
```ts
// taro-react/src/render.ts
import { TaroReconciler } from './reconciler'
class Root {
    constructor(renderer, domContainer){
	this.renderer = renderer
        // 值得注意的是，传入ConcurrentMode，则会启用了React18中并发新特性
	this.internalRoot = renderer.createContainer(domContainer, 0/** LegacyRoot: react-reconciler/src/ReactRootTags.js */, false, null)
    }
    render(children, cb){
	const { renderer, internalRoot } = this
	renderer.updateContainer(children, internalRoot, null, cb)
	return renderer.getPublicRootInstance(internalRoot)
    }
    unmount (cb: Callback) {
        this.renderer.updateContainer(null, this.internalRoot, null, cb)
    }
}
export function render(element, domContainer, cb){
    const root = new Root(TaroReconciler, domContainer)
    ContainerMap.set(domContainer, root)
    return root.render(element, cb)
}
```

## 3、封装为小程序版‘react-dom’
```ts
import {render} from './render'
export default {
  render,
  // 其他方法  
}
```

## render何时调用？
如果前端框架为React时，在编译时，会引入插件 taro-plugin-react, 插件内会调用 modifyMiniWebpackChain —> setAlias
```ts
if(framework === 'react'){
    // 别名，在小程序内调用ReactDOM就是刚才封装的小程序版react-dom
    alias.set('react-dom$', '@tarojs/react')
}
```

用户编写的app.js会被 createReactApp 方法包裹，在createReactApp方法中会调用 ReactDOM.render 方法
```ts
// taro-plugin-react/src/runtime/connect.ts
if (process.env.TARO_ENV !== 'h5') {
    appWrapper = ReactDOM.render?.(h(AppWrapper), document.getElementById('app'))
}
```

<img src="./images/taro react-mini.png" />