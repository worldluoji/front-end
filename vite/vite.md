# vite

## 为什么使用vite
由于 webpack 在项目调试之前，要把所有文件的依赖关系收集完，打包处理后才能启动测试，
很多大项目我们执行调试命令后需要等 1 分钟以上才能开始调试。

这对于开发者来说，这段时间除了摸鱼什么都干不了，而且热更新也需要等几秒钟才能生效，极大地影响了我们开发的效率。
所以针对 webpack 这种打包 bundle 的思路，社区就诞生了 bundless 的框架，Vite 就是其中的佼佼者。

前端的项目之所以需要 webpack 打包，是因为浏览器里的 JavaScript 没有很好的方式去引入其他文件。
webpack 提供的打包功能可以帮助我们更好地组织开发代码，但是现在大部分浏览器都支持了 ES6 的 module 功能，
我们在浏览器内使用 type="module"标记一个 script 后，在 src/main.js 中就可以直接使用 import 语法去引入一个新的 JavaScript 文件。
<em>这样我们其实可以不依赖 webpack 的打包功能，利用浏览器的 module 功能就可以重新组织我们的代码</em>。

```
 <script type="module" src="/src/main.js"></script>
```

<br>

## vite原理
三个问题：
- 浏览器的 module 功能有一些限制需要额外处理。浏览器识别出 JavaScript 中的 import 语句后，
会发起一个新的网络请求去获取新的文件，所以只支持 /、./ 和…/ 开头的路径。
- 浏览器并不知道 Vue 是从哪来，我们第一个要做的，就是分析文件中的 import 语句。
如果路径不是一个相对路径或者绝对路径，那就说明这个模块是来自 node_modules，我们需要去 node_modules 查找这个文件的入口文件后返回浏览器。
- ./App.vue 是相对路径，可以找到文件，但是浏览器不支持 .vue 文件的解析，并且 index.css 也不是一个合法的 JavaScript 文件。

解决以上三个问题，才能让 Vue 项目很好地在浏览器里跑起来。

首先我们需要使用 Koa 搭建一个 server，用来<em>拦截浏览器发出的所有网络请求</em>，才能实现上述功能。
在下面代码中，我们使用 Koa 启动了一个服务器，并且访问首页内容读取 index.html 的内容。